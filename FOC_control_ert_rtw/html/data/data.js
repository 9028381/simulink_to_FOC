var dataJson = {"arch":{"ispc":true,"isunix":false,"ismac":false},"build":"foc/FOC_control","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"D:\\DATA\\simulink\\data\\FOC_control_ert_rtw","tag":"","groupDisplay":"主文件","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: ert_main.c\r\n *\r\n * Code generated for Simulink model 'FOC_control'.\r\n *\r\n * Model version                  : 5.63\r\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\r\n * C/C++ source code generated on : Sat Feb  8 23:02:14 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: STMicroelectronics->ST10/Super10\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include <stddef.h>\r\n#include <stdio.h>            /* This example main program uses printf/fflush */\r\n#include \"FOC_control.h\"               /* Model header file */\r\n\r\n/*\r\n * Associating rt_OneStep with a real-time clock or interrupt service routine\r\n * is what makes the generated code \"real-time\".  The function rt_OneStep is\r\n * always associated with the base rate of the model.  Subrates are managed\r\n * by the base rate from inside the generated code.  Enabling/disabling\r\n * interrupts and floating point context switches are target specific.  This\r\n * example code indicates where these should take place relative to executing\r\n * the generated code step function.  Overrun behavior should be tailored to\r\n * your application needs.  This example simply sets an error status in the\r\n * real-time model and returns from rt_OneStep.\r\n */\r\nvoid rt_OneStep(void);\r\nvoid rt_OneStep(void)\r\n{\r\n  static boolean_T OverrunFlag = false;\r\n\r\n  /* Disable interrupts here */\r\n\r\n  /* Check for overrun */\r\n  if (OverrunFlag) {\r\n    rtmSetErrorStatus(FOC_control_M, \"Overrun\");\r\n    return;\r\n  }\r\n\r\n  OverrunFlag = true;\r\n\r\n  /* Save FPU context here (if necessary) */\r\n  /* Re-enable timer or interrupt here */\r\n  /* Set model inputs here */\r\n\r\n  /* Step the model */\r\n  FOC_control_step();\r\n\r\n  /* Get model outputs here */\r\n\r\n  /* Indicate task complete */\r\n  OverrunFlag = false;\r\n\r\n  /* Disable interrupts here */\r\n  /* Restore FPU context here (if necessary) */\r\n  /* Enable interrupts here */\r\n}\r\n\r\n/*\r\n * The example main function illustrates what is required by your\r\n * application code to initialize, execute, and terminate the generated code.\r\n * Attaching rt_OneStep to a real-time clock is target specific. This example\r\n * illustrates how you do this relative to initializing the model.\r\n */\r\nint_T main(int_T argc, const char *argv[])\r\n{\r\n  /* Unused arguments */\r\n  (void)(argc);\r\n  (void)(argv);\r\n\r\n  /* Initialize model */\r\n  FOC_control_initialize();\r\n\r\n  /* Attach rt_OneStep to a timer or interrupt service routine with\r\n   * period 0.0001 seconds (base rate of the model) here.\r\n   * The call syntax for rt_OneStep is\r\n   *\r\n   *  rt_OneStep();\r\n   */\r\n  printf(\"Warning: The simulation will run forever. \"\r\n         \"Generated ERT main won't simulate model step behavior. \"\r\n         \"To change this behavior select the 'MAT-file logging' option.\\n\");\r\n  fflush((NULL));\r\n  while (rtmGetErrorStatus(FOC_control_M) == (NULL)) {\r\n    /*  Perform application tasks here */\r\n  }\r\n\r\n  /* Terminate model */\r\n  FOC_control_terminate();\r\n  return 0;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"FOC_control.c","type":"source","group":"model","path":"D:\\DATA\\simulink\\data\\FOC_control_ert_rtw","tag":"","groupDisplay":"模型文件","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: FOC_control.c\r\n *\r\n * Code generated for Simulink model 'FOC_control'.\r\n *\r\n * Model version                  : 5.63\r\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\r\n * C/C++ source code generated on : Sat Feb  8 23:02:14 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: STMicroelectronics->ST10/Super10\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"FOC_control.h\"\r\n#include \"rtwtypes.h\"\r\n#include \"FOC_control_private.h\"\r\n#include <math.h>\r\n#include \"rt_nonfinite.h\"\r\n#include <float.h>\r\n#include \"rt_defines.h\"\r\n\r\n/* Block signals (default storage) */\r\nB_FOC_control_T FOC_control_B;\r\n\r\n/* Block states (default storage) */\r\nDW_FOC_control_T FOC_control_DW;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\nExtU_FOC_control_T FOC_control_U;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nExtY_FOC_control_T FOC_control_Y;\r\n\r\n/* Real-time model */\r\nstatic RT_MODEL_FOC_control_T FOC_control_M_;\r\nRT_MODEL_FOC_control_T *const FOC_control_M = &FOC_control_M_;\r\nreal_T look1_pbinlxpw(real_T u0, const real_T bp0[], const real_T table[],\r\n                      uint32_T prevIndex[], uint32_T maxIndex)\r\n{\r\n  real_T frac;\r\n  real_T yL_0d0;\r\n  uint32_T bpIdx;\r\n  uint32_T found;\r\n  uint32_T iLeft;\r\n  uint32_T iRght;\r\n\r\n  /* Column-major Lookup 1-D\r\n     Search method: 'binary'\r\n     Use previous index: 'on'\r\n     Interpolation method: 'Linear point-slope'\r\n     Extrapolation method: 'Linear'\r\n     Use last breakpoint for index at or above upper limit: 'off'\r\n     Remove protection against out-of-range input in generated code: 'off'\r\n   */\r\n  /* Prelookup - Index and Fraction\r\n     Index Search method: 'binary'\r\n     Extrapolation method: 'Linear'\r\n     Use previous index: 'on'\r\n     Use last breakpoint for index at or above upper limit: 'off'\r\n     Remove protection against out-of-range input in generated code: 'off'\r\n   */\r\n  if (u0 <= bp0[0UL]) {\r\n    bpIdx = 0UL;\r\n    frac = (u0 - bp0[0UL]) / (bp0[1UL] - bp0[0UL]);\r\n  } else if (u0 < bp0[maxIndex]) {\r\n    /* Binary Search using Previous Index */\r\n    bpIdx = prevIndex[0UL];\r\n    iLeft = 0UL;\r\n    iRght = maxIndex;\r\n    found = 0UL;\r\n    while (found == 0UL) {\r\n      if (u0 < bp0[bpIdx]) {\r\n        iRght = bpIdx - 1UL;\r\n        bpIdx = ((bpIdx + iLeft) - 1UL) >> 1UL;\r\n      } else if (u0 < bp0[bpIdx + 1UL]) {\r\n        found = 1UL;\r\n      } else {\r\n        iLeft = bpIdx + 1UL;\r\n        bpIdx = ((bpIdx + iRght) + 1UL) >> 1UL;\r\n      }\r\n    }\r\n\r\n    frac = (u0 - bp0[bpIdx]) / (bp0[bpIdx + 1UL] - bp0[bpIdx]);\r\n  } else {\r\n    bpIdx = maxIndex - 1UL;\r\n    frac = (u0 - bp0[maxIndex - 1UL]) / (bp0[maxIndex] - bp0[maxIndex - 1UL]);\r\n  }\r\n\r\n  prevIndex[0UL] = bpIdx;\r\n\r\n  /* Column-major Interpolation 1-D\r\n     Interpolation method: 'Linear point-slope'\r\n     Use last breakpoint for index at or above upper limit: 'off'\r\n     Overflow mode: 'portable wrapping'\r\n   */\r\n  yL_0d0 = table[bpIdx];\r\n  return (table[bpIdx + 1UL] - yL_0d0) * frac + yL_0d0;\r\n}\r\n\r\nreal_T rt_remd_snf(real_T u0, real_T u1)\r\n{\r\n  real_T q;\r\n  real_T y;\r\n  if (rtIsNaN(u0) || rtIsNaN(u1) || rtIsInf(u0)) {\r\n    y = (rtNaN);\r\n  } else if (rtIsInf(u1)) {\r\n    y = u0;\r\n  } else {\r\n    if (u1 < 0.0) {\r\n      q = ceil(u1);\r\n    } else {\r\n      q = floor(u1);\r\n    }\r\n\r\n    if ((u1 != 0.0) && (u1 != q)) {\r\n      q = fabs(u0 / u1);\r\n      if (!(fabs(q - floor(q + 0.5)) > DBL_EPSILON * q)) {\r\n        y = 0.0 * u0;\r\n      } else {\r\n        y = fmod(u0, u1);\r\n      }\r\n    } else {\r\n      y = fmod(u0, u1);\r\n    }\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\nreal_T rt_hypotd_snf(real_T u0, real_T u1)\r\n{\r\n  real_T a;\r\n  real_T b;\r\n  real_T y;\r\n  a = fabs(u0);\r\n  b = fabs(u1);\r\n  if (a < b) {\r\n    a /= b;\r\n    y = sqrt(a * a + 1.0) * b;\r\n  } else if (a > b) {\r\n    b /= a;\r\n    y = sqrt(b * b + 1.0) * a;\r\n  } else if (rtIsNaN(b)) {\r\n    y = (rtNaN);\r\n  } else {\r\n    y = a * 1.4142135623730951;\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\nreal_T rt_atan2d_snf(real_T u0, real_T u1)\r\n{\r\n  real_T y;\r\n  int16_T tmp;\r\n  int16_T tmp_0;\r\n  if (rtIsNaN(u0) || rtIsNaN(u1)) {\r\n    y = (rtNaN);\r\n  } else if (rtIsInf(u0) && rtIsInf(u1)) {\r\n    if (u0 > 0.0) {\r\n      tmp = 1;\r\n    } else {\r\n      tmp = -1;\r\n    }\r\n\r\n    if (u1 > 0.0) {\r\n      tmp_0 = 1;\r\n    } else {\r\n      tmp_0 = -1;\r\n    }\r\n\r\n    y = atan2(tmp, tmp_0);\r\n  } else if (u1 == 0.0) {\r\n    if (u0 > 0.0) {\r\n      y = RT_PI / 2.0;\r\n    } else if (u0 < 0.0) {\r\n      y = -(RT_PI / 2.0);\r\n    } else {\r\n      y = 0.0;\r\n    }\r\n  } else {\r\n    y = atan2(u0, u1);\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\nreal_T rt_modd_snf(real_T u0, real_T u1)\r\n{\r\n  real_T q;\r\n  real_T y;\r\n  boolean_T yEq;\r\n  y = u0;\r\n  if (u1 == 0.0) {\r\n    if (u0 == 0.0) {\r\n      y = u1;\r\n    }\r\n  } else if (rtIsNaN(u0) || rtIsNaN(u1) || rtIsInf(u0)) {\r\n    y = (rtNaN);\r\n  } else if (u0 == 0.0) {\r\n    y = 0.0 / u1;\r\n  } else if (rtIsInf(u1)) {\r\n    if ((u1 < 0.0) != (u0 < 0.0)) {\r\n      y = u1;\r\n    }\r\n  } else {\r\n    y = fmod(u0, u1);\r\n    yEq = (y == 0.0);\r\n    if ((!yEq) && (u1 > floor(u1))) {\r\n      q = fabs(u0 / u1);\r\n      yEq = !(fabs(q - floor(q + 0.5)) > DBL_EPSILON * q);\r\n    }\r\n\r\n    if (yEq) {\r\n      y = u1 * 0.0;\r\n    } else if ((u0 < 0.0) != (u1 < 0.0)) {\r\n      y += u1;\r\n    }\r\n  }\r\n\r\n  return y;\r\n}\r\n\r\n/* Model step function */\r\nvoid FOC_control_step(void)\r\n{\r\n  real_T rtb_Sum1_ft;\r\n  real_T rtb_Sum1_kl;\r\n  real_T rtb_Sum_c;\r\n  real_T rtb_Sum_f;\r\n  real_T rtb_Sum_k;\r\n  real_T rtb_Switch1_idx_1;\r\n  real_T rtb_iab_idx_0;\r\n  real_T rtb_iab_idx_1;\r\n  real_T rtb_rx;\r\n  real_T rtb_thetay;\r\n  real_T rtb_uDLookupTable3;\r\n  int16_T tableOffset;\r\n  boolean_T rtb_RelationalOperator1_i;\r\n  boolean_T rtb_RelationalOperator2_l;\r\n  boolean_T rtb_RelationalOperator_gb;\r\n\r\n  /* Outport: '<Root>/Outport' incorporates:\r\n   *  UnitDelay: '<S1>/Unit Delay'\r\n   */\r\n  FOC_control_Y.Outport = FOC_control_DW.UnitDelay_DSTATE;\r\n\r\n  /* Outport: '<Root>/Outport1' incorporates:\r\n   *  UnitDelay: '<S1>/Unit Delay1'\r\n   */\r\n  FOC_control_Y.Outport1 = FOC_control_DW.UnitDelay1_DSTATE;\r\n\r\n  /* Outport: '<Root>/Outport2' incorporates:\r\n   *  UnitDelay: '<S1>/Unit Delay2'\r\n   */\r\n  FOC_control_Y.Outport2 = FOC_control_DW.UnitDelay2_DSTATE;\r\n\r\n  /* Gain: '<S10>/1//R' incorporates:\r\n   *  Gain: '<S10>/1//K'\r\n   *  Inport: '<Root>/iabc'\r\n   *  Sum: '<S10>/Sum'\r\n   */\r\n  rtb_iab_idx_0 = (FOC_control_ConstB.Gain - FOC_control_U.vabc[0]) * 0.05 *\r\n    200.0;\r\n  rtb_iab_idx_1 = (FOC_control_ConstB.Gain - FOC_control_U.vabc[1]) * 0.05 *\r\n    200.0;\r\n\r\n  /* Outputs for Atomic SubSystem: '<S5>/Clarke Transform' */\r\n  /* Gain: '<S112>/one_by_sqrt3' incorporates:\r\n   *  Sum: '<S112>/a_plus_2b'\r\n   */\r\n  rtb_Sum1_ft = ((rtb_iab_idx_0 + rtb_iab_idx_1) + rtb_iab_idx_1) *\r\n    0.57735026918962584;\r\n\r\n  /* End of Outputs for SubSystem: '<S5>/Clarke Transform' */\r\n\r\n  /* Sum: '<S6>/Sum' incorporates:\r\n   *  Constant: '<S6>/Constant'\r\n   *  Gain: '<S6>/Gain1'\r\n   *  Inport: '<Root>/Angle'\r\n   *  Math: '<S6>/Rem'\r\n   */\r\n  rtb_thetay = rt_remd_snf(6.0 * FOC_control_U.Angle, 6.2831853071795862) -\r\n    1.5707963267948966;\r\n\r\n  /* Trigonometry: '<S5>/SinCos1' incorporates:\r\n   *  Trigonometry: '<S7>/SinCos1'\r\n   */\r\n  rtb_Sum_f = sin(rtb_thetay);\r\n  rtb_uDLookupTable3 = cos(rtb_thetay);\r\n\r\n  /* Outputs for Atomic SubSystem: '<S5>/Park Transform' */\r\n  /* Outputs for Atomic SubSystem: '<S5>/Clarke Transform' */\r\n  /* Sum: '<S1>/Sum1' incorporates:\r\n   *  AlgorithmDescriptorDelegate generated from: '<S112>/a16'\r\n   *  Constant: '<S1>/Constant'\r\n   *  Product: '<S113>/acos'\r\n   *  Product: '<S113>/bsin'\r\n   *  Sum: '<S113>/sum_Ds'\r\n   *  Trigonometry: '<S5>/SinCos1'\r\n   */\r\n  rtb_iab_idx_1 = 0.0 - (rtb_iab_idx_0 * rtb_uDLookupTable3 + rtb_Sum1_ft *\r\n    rtb_Sum_f);\r\n\r\n  /* End of Outputs for SubSystem: '<S5>/Clarke Transform' */\r\n  /* End of Outputs for SubSystem: '<S5>/Park Transform' */\r\n\r\n  /* Sum: '<S104>/Sum' incorporates:\r\n   *  DiscreteIntegrator: '<S95>/Integrator'\r\n   *  Sum: '<S1>/Sum1'\r\n   */\r\n  rtb_Sum_c = rtb_iab_idx_1 + FOC_control_DW.Integrator_DSTATE;\r\n\r\n  /* Sum: '<S3>/Sum' incorporates:\r\n   *  Inport: '<Root>/Angle'\r\n   *  Inport: '<Root>/Tar'\r\n   */\r\n  rtb_Sum_k = FOC_control_U.Tar - FOC_control_U.Angle;\r\n\r\n  /* MATLAB Function: '<S3>/MATLAB Function' */\r\n  if (rtb_Sum_k < -3.1415926535897931) {\r\n    rtb_Sum_k += 6.2831853071795862;\r\n  } else if (rtb_Sum_k > 3.1415926535897931) {\r\n    rtb_Sum_k -= 6.2831853071795862;\r\n  }\r\n\r\n  /* End of MATLAB Function: '<S3>/MATLAB Function' */\r\n\r\n  /* Switch: '<S1>/Switch1' incorporates:\r\n   *  Constant: '<S12>/Constant'\r\n   *  Inport: '<Root>/Mode'\r\n   *  Inport: '<Root>/Tar'\r\n   *  RelationalOperator: '<S12>/Compare'\r\n   */\r\n  if (FOC_control_U.Mode < 2.0) {\r\n    /* Sum: '<S56>/Sum' incorporates:\r\n     *  DiscreteIntegrator: '<S47>/Integrator'\r\n     *  Gain: '<S52>/Proportional Gain'\r\n     */\r\n    rtb_thetay = 5.0 * rtb_Sum_k + FOC_control_DW.Integrator_DSTATE_o;\r\n\r\n    /* Saturate: '<S54>/Saturation' */\r\n    if (rtb_thetay > 50.0) {\r\n      rtb_thetay = 50.0;\r\n    } else if (rtb_thetay < -50.0) {\r\n      rtb_thetay = -50.0;\r\n    }\r\n\r\n    /* End of Saturate: '<S54>/Saturation' */\r\n  } else {\r\n    rtb_thetay = FOC_control_U.Tar;\r\n  }\r\n\r\n  /* End of Switch: '<S1>/Switch1' */\r\n\r\n  /* Sum: '<S9>/Sum1' incorporates:\r\n   *  Inport: '<Root>/Speed'\r\n   */\r\n  rtb_Sum1_kl = rtb_thetay - FOC_control_U.Speed;\r\n\r\n  /* Switch: '<S1>/Switch2' incorporates:\r\n   *  Constant: '<S13>/Constant'\r\n   *  Inport: '<Root>/Mode'\r\n   *  Inport: '<Root>/Tar'\r\n   *  RelationalOperator: '<S13>/Compare'\r\n   */\r\n  if (FOC_control_U.Mode < 3.0) {\r\n    /* Sum: '<S223>/Sum' incorporates:\r\n     *  DiscreteIntegrator: '<S214>/Integrator'\r\n     *  Gain: '<S219>/Proportional Gain'\r\n     */\r\n    rtb_thetay = 5.0 * rtb_Sum1_kl + FOC_control_DW.Integrator_DSTATE_a;\r\n\r\n    /* Saturate: '<S221>/Saturation' */\r\n    if (rtb_thetay > 5.0) {\r\n      rtb_thetay = 5.0;\r\n    } else if (rtb_thetay < -5.0) {\r\n      rtb_thetay = -5.0;\r\n    }\r\n\r\n    /* End of Saturate: '<S221>/Saturation' */\r\n  } else {\r\n    rtb_thetay = FOC_control_U.Tar;\r\n  }\r\n\r\n  /* End of Switch: '<S1>/Switch2' */\r\n\r\n  /* Outputs for Atomic SubSystem: '<S5>/Park Transform' */\r\n  /* Outputs for Atomic SubSystem: '<S5>/Clarke Transform' */\r\n  /* Sum: '<S1>/Sum2' incorporates:\r\n   *  AlgorithmDescriptorDelegate generated from: '<S112>/a16'\r\n   *  Product: '<S113>/asin'\r\n   *  Product: '<S113>/bcos'\r\n   *  Sum: '<S113>/sum_Qs'\r\n   *  Trigonometry: '<S5>/SinCos1'\r\n   */\r\n  rtb_iab_idx_0 = rtb_thetay - (rtb_Sum1_ft * rtb_uDLookupTable3 - rtb_iab_idx_0\r\n    * rtb_Sum_f);\r\n\r\n  /* End of Outputs for SubSystem: '<S5>/Clarke Transform' */\r\n  /* End of Outputs for SubSystem: '<S5>/Park Transform' */\r\n\r\n  /* Sum: '<S174>/Sum' incorporates:\r\n   *  DiscreteIntegrator: '<S165>/Integrator'\r\n   */\r\n  rtb_Sum1_ft = rtb_iab_idx_0 + FOC_control_DW.Integrator_DSTATE_j;\r\n\r\n  /* Saturate: '<S172>/Saturation' */\r\n  if (rtb_Sum1_ft > 5.0) {\r\n    rtb_Sum1_ft = 5.0;\r\n  } else if (rtb_Sum1_ft < -5.0) {\r\n    rtb_Sum1_ft = -5.0;\r\n  }\r\n\r\n  /* End of Saturate: '<S172>/Saturation' */\r\n\r\n  /* Outputs for Atomic SubSystem: '<S7>/Inverse Park Transform1' */\r\n  /* Switch: '<S117>/Switch' incorporates:\r\n   *  Product: '<S115>/dcos'\r\n   *  Product: '<S115>/dsin'\r\n   *  Product: '<S115>/qcos'\r\n   *  Product: '<S115>/qsin'\r\n   *  Sum: '<S115>/sum_alpha'\r\n   *  Sum: '<S115>/sum_beta'\r\n   */\r\n  rtb_thetay = rtb_Sum_c * rtb_uDLookupTable3 - rtb_Sum1_ft * rtb_Sum_f;\r\n  rtb_Sum_c = rtb_Sum1_ft * rtb_uDLookupTable3 + rtb_Sum_c * rtb_Sum_f;\r\n\r\n  /* Switch: '<S119>/Switch' incorporates:\r\n   *  AlgorithmDescriptorDelegate generated from: '<S115>/a16'\r\n   *  Fcn: '<S122>/x->r'\r\n   *  Switch: '<S119>/Switch2'\r\n   */\r\n  rtb_Sum_f = rt_hypotd_snf(rtb_thetay, rtb_Sum_c);\r\n\r\n  /* End of Outputs for SubSystem: '<S7>/Inverse Park Transform1' */\r\n\r\n  /* Saturate: '<S119>/0<m<1 ' */\r\n  if (rtb_Sum_f > 1.0) {\r\n    rtb_Sum_f = 1.0;\r\n  }\r\n\r\n  /* End of Saturate: '<S119>/0<m<1 ' */\r\n\r\n  /* Outputs for Atomic SubSystem: '<S7>/Inverse Park Transform1' */\r\n  /* Math: '<S119>/Math Function2' incorporates:\r\n   *  AlgorithmDescriptorDelegate generated from: '<S115>/a16'\r\n   *  Constant: '<S119>/Constant2'\r\n   *  Fcn: '<S122>/x->theta'\r\n   *  Switch: '<S119>/Switch1'\r\n   *  Switch: '<S119>/Switch3'\r\n   */\r\n  rtb_thetay = rt_modd_snf(rt_atan2d_snf(rtb_Sum_c, rtb_thetay),\r\n    6.2831853071795862);\r\n\r\n  /* End of Outputs for SubSystem: '<S7>/Inverse Park Transform1' */\r\n\r\n  /* Outputs for Enabled SubSystem: '<S118>/SV Modulator Pattern #1' incorporates:\r\n   *  EnablePort: '<S120>/Enable'\r\n   */\r\n  /* Lookup_n-D: '<S124>/1-D Lookup Table' incorporates:\r\n   *  Math: '<S119>/Math Function2'\r\n   */\r\n  rtb_uDLookupTable3 = look1_pbinlxpw(rtb_thetay, FOC_control_ConstP.pooled5,\r\n    FOC_control_ConstP.pooled4, &FOC_control_DW.m_bpIndex_e, 5UL);\r\n\r\n  /* Rounding: '<S124>/Rounding Function' */\r\n  rtb_uDLookupTable3 = floor(rtb_uDLookupTable3);\r\n\r\n  /* Sum: '<S123>/Sum4' incorporates:\r\n   *  Constant: '<S123>/Constant1'\r\n   *  Constant: '<S123>/Constant2'\r\n   *  Product: '<S123>/Product1'\r\n   *  Sum: '<S123>/Sum1'\r\n   */\r\n  rtb_Sum_c = rtb_thetay - (rtb_uDLookupTable3 - 1.0) * 1.0471975511965976;\r\n\r\n  /* Product: '<S123>/Product' incorporates:\r\n   *  Constant: '<S123>/Constant'\r\n   *  Sum: '<S123>/Sum'\r\n   *  Trigonometry: '<S123>/Trigonometric Function'\r\n   *  Trigonometry: '<S123>/Trigonometric Function1'\r\n   */\r\n  rtb_thetay = cos(rtb_Sum_c + 0.52359877559829882) * rtb_Sum_f;\r\n  rtb_Sum_c = rtb_Sum_f * sin(rtb_Sum_c);\r\n\r\n  /* Gain: '<S123>/1//Fc' incorporates:\r\n   *  Constant: '<S123>/Constant8'\r\n   *  Sum: '<S123>/Sum2'\r\n   *  Sum: '<S123>/Sum3'\r\n   */\r\n  rtb_Sum1_ft = (1.0 - (rtb_thetay + rtb_Sum_c)) * 0.001;\r\n\r\n  /* Switch: '<S123>/Switch1' incorporates:\r\n   *  Constant: '<S124>/Constant1'\r\n   *  Gain: '<S123>/1//Fc'\r\n   *  Math: '<S124>/Math Function1'\r\n   */\r\n  if (rt_modd_snf(rtb_uDLookupTable3, 2.0) >= 0.5) {\r\n    rtb_Sum_f = 0.001 * rtb_thetay;\r\n    rtb_Switch1_idx_1 = 0.001 * rtb_Sum_c;\r\n  } else {\r\n    rtb_Sum_f = 0.001 * rtb_Sum_c;\r\n    rtb_Switch1_idx_1 = 0.001 * rtb_thetay;\r\n  }\r\n\r\n  /* Gain: '<S126>/Gain' incorporates:\r\n   *  Constant: '<S129>/Constant2'\r\n   *  DigitalClock: '<S129>/Digital Clock'\r\n   *  Fcn: '<S126>/Fcn'\r\n   *  Fcn: '<S129>/Fcn'\r\n   *  Gain: '<S129>/1\\ib1'\r\n   *  Math: '<S129>/Math Function'\r\n   */\r\n  rtb_Sum_c = ((1000.0 * rt_remd_snf(((FOC_control_M->Timing.clockTick0) *\r\n    0.0001), 0.001) * 2.0 - 1.0) + 1.0) * 0.5 * 0.001;\r\n\r\n  /* Gain: '<S128>/1//4' incorporates:\r\n   *  Switch: '<S123>/Switch1'\r\n   */\r\n  rtb_rx = 0.25 * rtb_Sum1_ft;\r\n\r\n  /* Gain: '<S128>/ 1//2 ' */\r\n  rtb_Sum_f *= 0.5;\r\n\r\n  /* Sum: '<S128>/Sum5' */\r\n  rtb_thetay = rtb_rx + rtb_Sum_f;\r\n\r\n  /* RelationalOperator: '<S126>/Relational Operator' */\r\n  rtb_RelationalOperator_gb = (rtb_Sum_c >= rtb_thetay);\r\n\r\n  /* Gain: '<S128>/  1//2' */\r\n  rtb_Switch1_idx_1 *= 0.5;\r\n\r\n  /* Sum: '<S128>/Sum6' */\r\n  rtb_thetay += rtb_Switch1_idx_1;\r\n\r\n  /* RelationalOperator: '<S126>/Relational Operator1' */\r\n  rtb_RelationalOperator1_i = (rtb_Sum_c >= rtb_thetay);\r\n\r\n  /* Sum: '<S128>/Sum7' incorporates:\r\n   *  Gain: '<S128>/ 1//2'\r\n   *  Switch: '<S123>/Switch1'\r\n   */\r\n  rtb_thetay += 0.5 * rtb_Sum1_ft;\r\n\r\n  /* RelationalOperator: '<S126>/Relational Operator2' */\r\n  rtb_RelationalOperator2_l = (rtb_Sum_c >= rtb_thetay);\r\n\r\n  /* Sum: '<S128>/Sum8' */\r\n  rtb_thetay += rtb_Switch1_idx_1;\r\n\r\n  /* LookupNDDirect: '<S125>/Direct Look-Up Table (n-D)' incorporates:\r\n   *  Constant: '<S125>/Constant2'\r\n   *  Constant: '<S125>/Constant3'\r\n   *  Constant: '<S126>/Constant7'\r\n   *  RelationalOperator: '<S126>/Relational Operator3'\r\n   *  RelationalOperator: '<S126>/Relational Operator4'\r\n   *  RelationalOperator: '<S126>/Relational Operator5'\r\n   *  Sum: '<S125>/Sum'\r\n   *  Sum: '<S125>/Sum1'\r\n   *  Sum: '<S126>/Sum1'\r\n   *  Sum: '<S128>/Sum9'\r\n   *\r\n   * About '<S125>/Direct Look-Up Table (n-D)':\r\n   *  3-dimensional Direct Look-Up returning a Vector,\r\n   *  which is contiguous for column-major array\r\n   *     Remove protection against out-of-range input in generated code: 'off'\r\n   */\r\n  if (rtb_uDLookupTable3 - 1.0 > 5.0) {\r\n    rtb_uDLookupTable3 = 5.0;\r\n  } else if (rtb_uDLookupTable3 - 1.0 < 0.0) {\r\n    rtb_uDLookupTable3 = 0.0;\r\n  } else {\r\n    rtb_uDLookupTable3--;\r\n  }\r\n\r\n  tableOffset = (int16_T)(((real_T)((((((rtb_Sum_c >= rtb_rx) +\r\n    rtb_RelationalOperator_gb) + rtb_RelationalOperator1_i) +\r\n    rtb_RelationalOperator2_l) + (rtb_Sum_c >= rtb_thetay)) + (rtb_Sum_c >=\r\n    rtb_thetay + rtb_Sum_f)) + 1.0) - 1.0) * 3 + (int16_T)rtb_uDLookupTable3 *\r\n    21;\r\n\r\n  /* LookupNDDirect: '<S125>/Direct Look-Up Table (n-D)'\r\n   *\r\n   * About '<S125>/Direct Look-Up Table (n-D)':\r\n   *  3-dimensional Direct Look-Up returning a Vector,\r\n   *  which is contiguous for column-major array\r\n   *     Remove protection against out-of-range input in generated code: 'off'\r\n   */\r\n  FOC_control_B.Q1Q3Q5[0] =\r\n    FOC_control_ConstP.DirectLookUpTablenD_table[tableOffset];\r\n  FOC_control_B.Q1Q3Q5[1] =\r\n    FOC_control_ConstP.DirectLookUpTablenD_table[tableOffset + 1];\r\n  FOC_control_B.Q1Q3Q5[2] =\r\n    FOC_control_ConstP.DirectLookUpTablenD_table[tableOffset + 2];\r\n\r\n  /* End of Outputs for SubSystem: '<S118>/SV Modulator Pattern #1' */\r\n\r\n  /* Update for UnitDelay: '<S1>/Unit Delay' incorporates:\r\n   *  MultiPortSwitch: '<S118>/Multiport Switch'\r\n   */\r\n  FOC_control_DW.UnitDelay_DSTATE = FOC_control_B.Q1Q3Q5[0];\r\n\r\n  /* Update for UnitDelay: '<S1>/Unit Delay1' incorporates:\r\n   *  MultiPortSwitch: '<S118>/Multiport Switch'\r\n   */\r\n  FOC_control_DW.UnitDelay1_DSTATE = FOC_control_B.Q1Q3Q5[1];\r\n\r\n  /* Update for UnitDelay: '<S1>/Unit Delay2' incorporates:\r\n   *  MultiPortSwitch: '<S118>/Multiport Switch'\r\n   */\r\n  FOC_control_DW.UnitDelay2_DSTATE = FOC_control_B.Q1Q3Q5[2];\r\n\r\n  /* Update for DiscreteIntegrator: '<S95>/Integrator' */\r\n  FOC_control_DW.Integrator_DSTATE += rtb_iab_idx_1 * 0.0001;\r\n\r\n  /* Update for DiscreteIntegrator: '<S47>/Integrator' incorporates:\r\n   *  Gain: '<S44>/Integral Gain'\r\n   */\r\n  FOC_control_DW.Integrator_DSTATE_o += 3.0 * rtb_Sum_k * 0.0001;\r\n\r\n  /* Update for DiscreteIntegrator: '<S214>/Integrator' incorporates:\r\n   *  Gain: '<S211>/Integral Gain'\r\n   */\r\n  FOC_control_DW.Integrator_DSTATE_a += 3.0 * rtb_Sum1_kl * 0.0001;\r\n\r\n  /* Update for DiscreteIntegrator: '<S165>/Integrator' */\r\n  FOC_control_DW.Integrator_DSTATE_j += 0.0001 * rtb_iab_idx_0;\r\n\r\n  /* Update absolute time for base rate */\r\n  /* The \"clockTick0\" counts the number of times the code of this task has\r\n   * been executed. The resolution of this integer timer is 0.0001, which is the step size\r\n   * of the task. Size of \"clockTick0\" ensures timer will not overflow during the\r\n   * application lifespan selected.\r\n   */\r\n  FOC_control_M->Timing.clockTick0++;\r\n}\r\n\r\n/* Model initialize function */\r\nvoid FOC_control_initialize(void)\r\n{\r\n  /* Registration code */\r\n\r\n  /* initialize non-finites */\r\n  rt_InitInfAndNaN(sizeof(real_T));\r\n}\r\n\r\n/* Model terminate function */\r\nvoid FOC_control_terminate(void)\r\n{\r\n  /* (no terminate code required) */\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"FOC_control.h","type":"header","group":"model","path":"D:\\DATA\\simulink\\data\\FOC_control_ert_rtw","tag":"","groupDisplay":"模型文件","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: FOC_control.h\r\n *\r\n * Code generated for Simulink model 'FOC_control'.\r\n *\r\n * Model version                  : 5.63\r\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\r\n * C/C++ source code generated on : Sat Feb  8 23:02:14 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: STMicroelectronics->ST10/Super10\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_FOC_control_h_\r\n#define RTW_HEADER_FOC_control_h_\r\n#ifndef FOC_control_COMMON_INCLUDES_\r\n#define FOC_control_COMMON_INCLUDES_\r\n#include \"rtwtypes.h\"\r\n#endif                                 /* FOC_control_COMMON_INCLUDES_ */\r\n\r\n#include \"FOC_control_types.h\"\r\n#include \"rtGetInf.h\"\r\n#include \"rt_nonfinite.h\"\r\n\r\n/* Macros for accessing real-time model data structure */\r\n#ifndef rtmGetErrorStatus\r\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\r\n#endif\r\n\r\n#ifndef rtmSetErrorStatus\r\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\r\n#endif\r\n\r\n/* Block signals (default storage) */\r\ntypedef struct {\r\n  real_T Q1Q3Q5[3];                    /* '<S125>/Direct Look-Up Table (n-D)' */\r\n} B_FOC_control_T;\r\n\r\n/* Block states (default storage) for system '<Root>' */\r\ntypedef struct {\r\n  real_T UnitDelay_DSTATE;             /* '<S1>/Unit Delay' */\r\n  real_T UnitDelay1_DSTATE;            /* '<S1>/Unit Delay1' */\r\n  real_T UnitDelay2_DSTATE;            /* '<S1>/Unit Delay2' */\r\n  real_T Integrator_DSTATE;            /* '<S95>/Integrator' */\r\n  real_T Integrator_DSTATE_o;          /* '<S47>/Integrator' */\r\n  real_T Integrator_DSTATE_a;          /* '<S214>/Integrator' */\r\n  real_T Integrator_DSTATE_j;          /* '<S165>/Integrator' */\r\n  uint32_T m_bpIndex_e;                /* '<S124>/1-D Lookup Table' */\r\n} DW_FOC_control_T;\r\n\r\n/* Invariant block signals (default storage) */\r\ntypedef struct {\r\n  const real_T Gain;                   /* '<S10>/Gain' */\r\n} ConstB_FOC_control_T;\r\n\r\n/* Constant parameters (default storage) */\r\ntypedef struct {\r\n  /* Pooled Parameter (Mixed Expressions)\r\n   * Referenced by:\r\n   *   '<S121>/Look-Up Table  Determine the sector of U* based on alpha (rad). '\r\n   *   '<S124>/1-D Lookup Table'\r\n   *   '<S130>/1-D Lookup Table'\r\n   *   '<S130>/1-D Lookup Table1'\r\n   *   '<S130>/1-D Lookup Table2'\r\n   *   '<S130>/1-D Lookup Table3'\r\n   */\r\n  real_T pooled4[6];\r\n\r\n  /* Pooled Parameter (Expression: [0:pi/3:5*pi/3])\r\n   * Referenced by:\r\n   *   '<S121>/Look-Up Table  Determine the sector of U* based on alpha (rad). '\r\n   *   '<S124>/1-D Lookup Table'\r\n   */\r\n  real_T pooled5[6];\r\n\r\n  /* Expression: pat1\r\n   * Referenced by: '<S125>/Direct Look-Up Table (n-D)'\r\n   */\r\n  real_T DirectLookUpTablenD_table[126];\r\n} ConstP_FOC_control_T;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\ntypedef struct {\r\n  real_T Speed;                        /* '<Root>/Speed' */\r\n  real_T Angle;                        /* '<Root>/Angle' */\r\n  real_T vabc[3];                      /* '<Root>/iabc' */\r\n  real_T Tar;                          /* '<Root>/Tar' */\r\n  real_T Mode;                         /* '<Root>/Mode' */\r\n} ExtU_FOC_control_T;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\ntypedef struct {\r\n  real_T Outport;                      /* '<Root>/Outport' */\r\n  real_T Outport1;                     /* '<Root>/Outport1' */\r\n  real_T Outport2;                     /* '<Root>/Outport2' */\r\n} ExtY_FOC_control_T;\r\n\r\n/* Real-time Model Data Structure */\r\nstruct tag_RTM_FOC_control_T {\r\n  const char_T * volatile errorStatus;\r\n\r\n  /*\r\n   * Timing:\r\n   * The following substructure contains information regarding\r\n   * the timing information for the model.\r\n   */\r\n  struct {\r\n    uint32_T clockTick0;\r\n  } Timing;\r\n};\r\n\r\n/* Block signals (default storage) */\r\nextern B_FOC_control_T FOC_control_B;\r\n\r\n/* Block states (default storage) */\r\nextern DW_FOC_control_T FOC_control_DW;\r\n\r\n/* External inputs (root inport signals with default storage) */\r\nextern ExtU_FOC_control_T FOC_control_U;\r\n\r\n/* External outputs (root outports fed by signals with default storage) */\r\nextern ExtY_FOC_control_T FOC_control_Y;\r\nextern const ConstB_FOC_control_T FOC_control_ConstB;/* constant block i/o */\r\n\r\n/* Constant parameters (default storage) */\r\nextern const ConstP_FOC_control_T FOC_control_ConstP;\r\n\r\n/* Model entry point functions */\r\nextern void FOC_control_initialize(void);\r\nextern void FOC_control_step(void);\r\nextern void FOC_control_terminate(void);\r\n\r\n/* Real-time Model object */\r\nextern RT_MODEL_FOC_control_T *const FOC_control_M;\r\n\r\n/*-\r\n * These blocks were eliminated from the model due to optimizations:\r\n *\r\n * Block '<S1>/Scope' : Unused code path elimination\r\n * Block '<S1>/Scope1' : Unused code path elimination\r\n * Block '<S112>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S113>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S113>/Data Type Duplicate1' : Unused code path elimination\r\n * Block '<S5>/Scope' : Unused code path elimination\r\n * Block '<S115>/Data Type Duplicate' : Unused code path elimination\r\n * Block '<S115>/Data Type Duplicate1' : Unused code path elimination\r\n * Block '<S92>/Integral Gain' : Eliminated nontunable gain of 1\r\n * Block '<S100>/Proportional Gain' : Eliminated nontunable gain of 1\r\n * Block '<S162>/Integral Gain' : Eliminated nontunable gain of 1\r\n * Block '<S170>/Proportional Gain' : Eliminated nontunable gain of 1\r\n * Block '<S114>/Offset' : Unused code path elimination\r\n * Block '<S114>/Unary_Minus' : Unused code path elimination\r\n * Block '<S117>/Offset' : Unused code path elimination\r\n * Block '<S117>/Unary_Minus' : Unused code path elimination\r\n */\r\n\r\n/*-\r\n * The generated code includes comments that allow you to trace directly\r\n * back to the appropriate location in the model.  The basic format\r\n * is <system>/block_name, where system is the system number (uniquely\r\n * assigned by Simulink) and block_name is the name of the block.\r\n *\r\n * Note that this particular code originates from a subsystem build,\r\n * and has its own system numbers different from the parent model.\r\n * Refer to the system hierarchy for this subsystem below, and use the\r\n * MATLAB hilite_system command to trace the generated code back\r\n * to the parent model.  For example,\r\n *\r\n * hilite_system('foc/FOC_control')    - opens subsystem foc/FOC_control\r\n * hilite_system('foc/FOC_control/Kp') - opens and selects block Kp\r\n *\r\n * Here is the system hierarchy for this model\r\n *\r\n * '<Root>' : 'foc'\r\n * '<S1>'   : 'foc/FOC_control'\r\n * '<S2>'   : 'foc/FOC_control/Mode_control'\r\n * '<S3>'   : 'foc/FOC_control/angle_pid'\r\n * '<S4>'   : 'foc/FOC_control/d_pid'\r\n * '<S5>'   : 'foc/FOC_control/iab_2_qd'\r\n * '<S6>'   : 'foc/FOC_control/m2e_angle'\r\n * '<S7>'   : 'foc/FOC_control/q_control'\r\n * '<S8>'   : 'foc/FOC_control/q_pid'\r\n * '<S9>'   : 'foc/FOC_control/speed_pid'\r\n * '<S10>'  : 'foc/FOC_control/v_2_i'\r\n * '<S11>'  : 'foc/FOC_control/Mode_control/Compare To Constant'\r\n * '<S12>'  : 'foc/FOC_control/Mode_control/Compare To Constant1'\r\n * '<S13>'  : 'foc/FOC_control/Mode_control/Compare To Constant2'\r\n * '<S14>'  : 'foc/FOC_control/angle_pid/Angle_pid'\r\n * '<S15>'  : 'foc/FOC_control/angle_pid/MATLAB Function'\r\n * '<S16>'  : 'foc/FOC_control/angle_pid/Angle_pid/Anti-windup'\r\n * '<S17>'  : 'foc/FOC_control/angle_pid/Angle_pid/D Gain'\r\n * '<S18>'  : 'foc/FOC_control/angle_pid/Angle_pid/Filter'\r\n * '<S19>'  : 'foc/FOC_control/angle_pid/Angle_pid/Filter ICs'\r\n * '<S20>'  : 'foc/FOC_control/angle_pid/Angle_pid/I Gain'\r\n * '<S21>'  : 'foc/FOC_control/angle_pid/Angle_pid/Ideal P Gain'\r\n * '<S22>'  : 'foc/FOC_control/angle_pid/Angle_pid/Ideal P Gain Fdbk'\r\n * '<S23>'  : 'foc/FOC_control/angle_pid/Angle_pid/Integrator'\r\n * '<S24>'  : 'foc/FOC_control/angle_pid/Angle_pid/Integrator ICs'\r\n * '<S25>'  : 'foc/FOC_control/angle_pid/Angle_pid/N Copy'\r\n * '<S26>'  : 'foc/FOC_control/angle_pid/Angle_pid/N Gain'\r\n * '<S27>'  : 'foc/FOC_control/angle_pid/Angle_pid/P Copy'\r\n * '<S28>'  : 'foc/FOC_control/angle_pid/Angle_pid/Parallel P Gain'\r\n * '<S29>'  : 'foc/FOC_control/angle_pid/Angle_pid/Reset Signal'\r\n * '<S30>'  : 'foc/FOC_control/angle_pid/Angle_pid/Saturation'\r\n * '<S31>'  : 'foc/FOC_control/angle_pid/Angle_pid/Saturation Fdbk'\r\n * '<S32>'  : 'foc/FOC_control/angle_pid/Angle_pid/Sum'\r\n * '<S33>'  : 'foc/FOC_control/angle_pid/Angle_pid/Sum Fdbk'\r\n * '<S34>'  : 'foc/FOC_control/angle_pid/Angle_pid/Tracking Mode'\r\n * '<S35>'  : 'foc/FOC_control/angle_pid/Angle_pid/Tracking Mode Sum'\r\n * '<S36>'  : 'foc/FOC_control/angle_pid/Angle_pid/Tsamp - Integral'\r\n * '<S37>'  : 'foc/FOC_control/angle_pid/Angle_pid/Tsamp - Ngain'\r\n * '<S38>'  : 'foc/FOC_control/angle_pid/Angle_pid/postSat Signal'\r\n * '<S39>'  : 'foc/FOC_control/angle_pid/Angle_pid/preSat Signal'\r\n * '<S40>'  : 'foc/FOC_control/angle_pid/Angle_pid/Anti-windup/Passthrough'\r\n * '<S41>'  : 'foc/FOC_control/angle_pid/Angle_pid/D Gain/Disabled'\r\n * '<S42>'  : 'foc/FOC_control/angle_pid/Angle_pid/Filter/Disabled'\r\n * '<S43>'  : 'foc/FOC_control/angle_pid/Angle_pid/Filter ICs/Disabled'\r\n * '<S44>'  : 'foc/FOC_control/angle_pid/Angle_pid/I Gain/Internal Parameters'\r\n * '<S45>'  : 'foc/FOC_control/angle_pid/Angle_pid/Ideal P Gain/Passthrough'\r\n * '<S46>'  : 'foc/FOC_control/angle_pid/Angle_pid/Ideal P Gain Fdbk/Disabled'\r\n * '<S47>'  : 'foc/FOC_control/angle_pid/Angle_pid/Integrator/Discrete'\r\n * '<S48>'  : 'foc/FOC_control/angle_pid/Angle_pid/Integrator ICs/Internal IC'\r\n * '<S49>'  : 'foc/FOC_control/angle_pid/Angle_pid/N Copy/Disabled wSignal Specification'\r\n * '<S50>'  : 'foc/FOC_control/angle_pid/Angle_pid/N Gain/Disabled'\r\n * '<S51>'  : 'foc/FOC_control/angle_pid/Angle_pid/P Copy/Disabled'\r\n * '<S52>'  : 'foc/FOC_control/angle_pid/Angle_pid/Parallel P Gain/Internal Parameters'\r\n * '<S53>'  : 'foc/FOC_control/angle_pid/Angle_pid/Reset Signal/Disabled'\r\n * '<S54>'  : 'foc/FOC_control/angle_pid/Angle_pid/Saturation/Enabled'\r\n * '<S55>'  : 'foc/FOC_control/angle_pid/Angle_pid/Saturation Fdbk/Disabled'\r\n * '<S56>'  : 'foc/FOC_control/angle_pid/Angle_pid/Sum/Sum_PI'\r\n * '<S57>'  : 'foc/FOC_control/angle_pid/Angle_pid/Sum Fdbk/Disabled'\r\n * '<S58>'  : 'foc/FOC_control/angle_pid/Angle_pid/Tracking Mode/Disabled'\r\n * '<S59>'  : 'foc/FOC_control/angle_pid/Angle_pid/Tracking Mode Sum/Passthrough'\r\n * '<S60>'  : 'foc/FOC_control/angle_pid/Angle_pid/Tsamp - Integral/Passthrough'\r\n * '<S61>'  : 'foc/FOC_control/angle_pid/Angle_pid/Tsamp - Ngain/Passthrough'\r\n * '<S62>'  : 'foc/FOC_control/angle_pid/Angle_pid/postSat Signal/Forward_Path'\r\n * '<S63>'  : 'foc/FOC_control/angle_pid/Angle_pid/preSat Signal/Forward_Path'\r\n * '<S64>'  : 'foc/FOC_control/d_pid/Anti-windup'\r\n * '<S65>'  : 'foc/FOC_control/d_pid/D Gain'\r\n * '<S66>'  : 'foc/FOC_control/d_pid/Filter'\r\n * '<S67>'  : 'foc/FOC_control/d_pid/Filter ICs'\r\n * '<S68>'  : 'foc/FOC_control/d_pid/I Gain'\r\n * '<S69>'  : 'foc/FOC_control/d_pid/Ideal P Gain'\r\n * '<S70>'  : 'foc/FOC_control/d_pid/Ideal P Gain Fdbk'\r\n * '<S71>'  : 'foc/FOC_control/d_pid/Integrator'\r\n * '<S72>'  : 'foc/FOC_control/d_pid/Integrator ICs'\r\n * '<S73>'  : 'foc/FOC_control/d_pid/N Copy'\r\n * '<S74>'  : 'foc/FOC_control/d_pid/N Gain'\r\n * '<S75>'  : 'foc/FOC_control/d_pid/P Copy'\r\n * '<S76>'  : 'foc/FOC_control/d_pid/Parallel P Gain'\r\n * '<S77>'  : 'foc/FOC_control/d_pid/Reset Signal'\r\n * '<S78>'  : 'foc/FOC_control/d_pid/Saturation'\r\n * '<S79>'  : 'foc/FOC_control/d_pid/Saturation Fdbk'\r\n * '<S80>'  : 'foc/FOC_control/d_pid/Sum'\r\n * '<S81>'  : 'foc/FOC_control/d_pid/Sum Fdbk'\r\n * '<S82>'  : 'foc/FOC_control/d_pid/Tracking Mode'\r\n * '<S83>'  : 'foc/FOC_control/d_pid/Tracking Mode Sum'\r\n * '<S84>'  : 'foc/FOC_control/d_pid/Tsamp - Integral'\r\n * '<S85>'  : 'foc/FOC_control/d_pid/Tsamp - Ngain'\r\n * '<S86>'  : 'foc/FOC_control/d_pid/postSat Signal'\r\n * '<S87>'  : 'foc/FOC_control/d_pid/preSat Signal'\r\n * '<S88>'  : 'foc/FOC_control/d_pid/Anti-windup/Passthrough'\r\n * '<S89>'  : 'foc/FOC_control/d_pid/D Gain/Disabled'\r\n * '<S90>'  : 'foc/FOC_control/d_pid/Filter/Disabled'\r\n * '<S91>'  : 'foc/FOC_control/d_pid/Filter ICs/Disabled'\r\n * '<S92>'  : 'foc/FOC_control/d_pid/I Gain/Internal Parameters'\r\n * '<S93>'  : 'foc/FOC_control/d_pid/Ideal P Gain/Passthrough'\r\n * '<S94>'  : 'foc/FOC_control/d_pid/Ideal P Gain Fdbk/Disabled'\r\n * '<S95>'  : 'foc/FOC_control/d_pid/Integrator/Discrete'\r\n * '<S96>'  : 'foc/FOC_control/d_pid/Integrator ICs/Internal IC'\r\n * '<S97>'  : 'foc/FOC_control/d_pid/N Copy/Disabled wSignal Specification'\r\n * '<S98>'  : 'foc/FOC_control/d_pid/N Gain/Disabled'\r\n * '<S99>'  : 'foc/FOC_control/d_pid/P Copy/Disabled'\r\n * '<S100>' : 'foc/FOC_control/d_pid/Parallel P Gain/Internal Parameters'\r\n * '<S101>' : 'foc/FOC_control/d_pid/Reset Signal/Disabled'\r\n * '<S102>' : 'foc/FOC_control/d_pid/Saturation/Passthrough'\r\n * '<S103>' : 'foc/FOC_control/d_pid/Saturation Fdbk/Disabled'\r\n * '<S104>' : 'foc/FOC_control/d_pid/Sum/Sum_PI'\r\n * '<S105>' : 'foc/FOC_control/d_pid/Sum Fdbk/Disabled'\r\n * '<S106>' : 'foc/FOC_control/d_pid/Tracking Mode/Disabled'\r\n * '<S107>' : 'foc/FOC_control/d_pid/Tracking Mode Sum/Passthrough'\r\n * '<S108>' : 'foc/FOC_control/d_pid/Tsamp - Integral/Passthrough'\r\n * '<S109>' : 'foc/FOC_control/d_pid/Tsamp - Ngain/Passthrough'\r\n * '<S110>' : 'foc/FOC_control/d_pid/postSat Signal/Forward_Path'\r\n * '<S111>' : 'foc/FOC_control/d_pid/preSat Signal/Forward_Path'\r\n * '<S112>' : 'foc/FOC_control/iab_2_qd/Clarke Transform'\r\n * '<S113>' : 'foc/FOC_control/iab_2_qd/Park Transform'\r\n * '<S114>' : 'foc/FOC_control/iab_2_qd/Park Transform/Switch_Axis'\r\n * '<S115>' : 'foc/FOC_control/q_control/Inverse Park Transform1'\r\n * '<S116>' : 'foc/FOC_control/q_control/SVPWM Generator (2-Level)'\r\n * '<S117>' : 'foc/FOC_control/q_control/Inverse Park Transform1/Switch_Axis'\r\n * '<S118>' : 'foc/FOC_control/q_control/SVPWM Generator (2-Level)/Model'\r\n * '<S119>' : 'foc/FOC_control/q_control/SVPWM Generator (2-Level)/Model/Determine reference vector (U*)'\r\n * '<S120>' : 'foc/FOC_control/q_control/SVPWM Generator (2-Level)/Model/SV Modulator Pattern #1'\r\n * '<S121>' : 'foc/FOC_control/q_control/SVPWM Generator (2-Level)/Model/SV Modulator Pattern #2'\r\n * '<S122>' : 'foc/FOC_control/q_control/SVPWM Generator (2-Level)/Model/Determine reference vector (U*)/Cartesian to Polar'\r\n * '<S123>' : 'foc/FOC_control/q_control/SVPWM Generator (2-Level)/Model/SV Modulator Pattern #1/Compute time duration of switching states (Ta,Tb,To) '\r\n * '<S124>' : 'foc/FOC_control/q_control/SVPWM Generator (2-Level)/Model/SV Modulator Pattern #1/Determine the sector of U* based on alpha (rad). Also, determine if the sector number is odd'\r\n * '<S125>' : 'foc/FOC_control/q_control/SVPWM Generator (2-Level)/Model/SV Modulator Pattern #1/Generate  pulse pattern'\r\n * '<S126>' : 'foc/FOC_control/q_control/SVPWM Generator (2-Level)/Model/SV Modulator Pattern #1/Generate  pulse pattern/Determine interval of the PWM period based on Ta Tb and To'\r\n * '<S127>' : 'foc/FOC_control/q_control/SVPWM Generator (2-Level)/Model/SV Modulator Pattern #1/Generate  pulse pattern/Determine interval of the PWM period based on Ta Tb and To/Sawtooth Generator'\r\n * '<S128>' : 'foc/FOC_control/q_control/SVPWM Generator (2-Level)/Model/SV Modulator Pattern #1/Generate  pulse pattern/Determine interval of the PWM period based on Ta Tb and To/Subsystem'\r\n * '<S129>' : 'foc/FOC_control/q_control/SVPWM Generator (2-Level)/Model/SV Modulator Pattern #1/Generate  pulse pattern/Determine interval of the PWM period based on Ta Tb and To/Sawtooth Generator/Model'\r\n * '<S130>' : 'foc/FOC_control/q_control/SVPWM Generator (2-Level)/Model/SV Modulator Pattern #2/Conv_table'\r\n * '<S131>' : 'foc/FOC_control/q_control/SVPWM Generator (2-Level)/Model/SV Modulator Pattern #2/Polar to Cartesian'\r\n * '<S132>' : 'foc/FOC_control/q_control/SVPWM Generator (2-Level)/Model/SV Modulator Pattern #2/Triangle Generator'\r\n * '<S133>' : 'foc/FOC_control/q_control/SVPWM Generator (2-Level)/Model/SV Modulator Pattern #2/Triangle Generator/Model'\r\n * '<S134>' : 'foc/FOC_control/q_pid/Anti-windup'\r\n * '<S135>' : 'foc/FOC_control/q_pid/D Gain'\r\n * '<S136>' : 'foc/FOC_control/q_pid/Filter'\r\n * '<S137>' : 'foc/FOC_control/q_pid/Filter ICs'\r\n * '<S138>' : 'foc/FOC_control/q_pid/I Gain'\r\n * '<S139>' : 'foc/FOC_control/q_pid/Ideal P Gain'\r\n * '<S140>' : 'foc/FOC_control/q_pid/Ideal P Gain Fdbk'\r\n * '<S141>' : 'foc/FOC_control/q_pid/Integrator'\r\n * '<S142>' : 'foc/FOC_control/q_pid/Integrator ICs'\r\n * '<S143>' : 'foc/FOC_control/q_pid/N Copy'\r\n * '<S144>' : 'foc/FOC_control/q_pid/N Gain'\r\n * '<S145>' : 'foc/FOC_control/q_pid/P Copy'\r\n * '<S146>' : 'foc/FOC_control/q_pid/Parallel P Gain'\r\n * '<S147>' : 'foc/FOC_control/q_pid/Reset Signal'\r\n * '<S148>' : 'foc/FOC_control/q_pid/Saturation'\r\n * '<S149>' : 'foc/FOC_control/q_pid/Saturation Fdbk'\r\n * '<S150>' : 'foc/FOC_control/q_pid/Sum'\r\n * '<S151>' : 'foc/FOC_control/q_pid/Sum Fdbk'\r\n * '<S152>' : 'foc/FOC_control/q_pid/Tracking Mode'\r\n * '<S153>' : 'foc/FOC_control/q_pid/Tracking Mode Sum'\r\n * '<S154>' : 'foc/FOC_control/q_pid/Tsamp - Integral'\r\n * '<S155>' : 'foc/FOC_control/q_pid/Tsamp - Ngain'\r\n * '<S156>' : 'foc/FOC_control/q_pid/postSat Signal'\r\n * '<S157>' : 'foc/FOC_control/q_pid/preSat Signal'\r\n * '<S158>' : 'foc/FOC_control/q_pid/Anti-windup/Passthrough'\r\n * '<S159>' : 'foc/FOC_control/q_pid/D Gain/Disabled'\r\n * '<S160>' : 'foc/FOC_control/q_pid/Filter/Disabled'\r\n * '<S161>' : 'foc/FOC_control/q_pid/Filter ICs/Disabled'\r\n * '<S162>' : 'foc/FOC_control/q_pid/I Gain/Internal Parameters'\r\n * '<S163>' : 'foc/FOC_control/q_pid/Ideal P Gain/Passthrough'\r\n * '<S164>' : 'foc/FOC_control/q_pid/Ideal P Gain Fdbk/Disabled'\r\n * '<S165>' : 'foc/FOC_control/q_pid/Integrator/Discrete'\r\n * '<S166>' : 'foc/FOC_control/q_pid/Integrator ICs/Internal IC'\r\n * '<S167>' : 'foc/FOC_control/q_pid/N Copy/Disabled wSignal Specification'\r\n * '<S168>' : 'foc/FOC_control/q_pid/N Gain/Disabled'\r\n * '<S169>' : 'foc/FOC_control/q_pid/P Copy/Disabled'\r\n * '<S170>' : 'foc/FOC_control/q_pid/Parallel P Gain/Internal Parameters'\r\n * '<S171>' : 'foc/FOC_control/q_pid/Reset Signal/Disabled'\r\n * '<S172>' : 'foc/FOC_control/q_pid/Saturation/Enabled'\r\n * '<S173>' : 'foc/FOC_control/q_pid/Saturation Fdbk/Disabled'\r\n * '<S174>' : 'foc/FOC_control/q_pid/Sum/Sum_PI'\r\n * '<S175>' : 'foc/FOC_control/q_pid/Sum Fdbk/Disabled'\r\n * '<S176>' : 'foc/FOC_control/q_pid/Tracking Mode/Disabled'\r\n * '<S177>' : 'foc/FOC_control/q_pid/Tracking Mode Sum/Passthrough'\r\n * '<S178>' : 'foc/FOC_control/q_pid/Tsamp - Integral/Passthrough'\r\n * '<S179>' : 'foc/FOC_control/q_pid/Tsamp - Ngain/Passthrough'\r\n * '<S180>' : 'foc/FOC_control/q_pid/postSat Signal/Forward_Path'\r\n * '<S181>' : 'foc/FOC_control/q_pid/preSat Signal/Forward_Path'\r\n * '<S182>' : 'foc/FOC_control/speed_pid/Speed_pid'\r\n * '<S183>' : 'foc/FOC_control/speed_pid/Speed_pid/Anti-windup'\r\n * '<S184>' : 'foc/FOC_control/speed_pid/Speed_pid/D Gain'\r\n * '<S185>' : 'foc/FOC_control/speed_pid/Speed_pid/Filter'\r\n * '<S186>' : 'foc/FOC_control/speed_pid/Speed_pid/Filter ICs'\r\n * '<S187>' : 'foc/FOC_control/speed_pid/Speed_pid/I Gain'\r\n * '<S188>' : 'foc/FOC_control/speed_pid/Speed_pid/Ideal P Gain'\r\n * '<S189>' : 'foc/FOC_control/speed_pid/Speed_pid/Ideal P Gain Fdbk'\r\n * '<S190>' : 'foc/FOC_control/speed_pid/Speed_pid/Integrator'\r\n * '<S191>' : 'foc/FOC_control/speed_pid/Speed_pid/Integrator ICs'\r\n * '<S192>' : 'foc/FOC_control/speed_pid/Speed_pid/N Copy'\r\n * '<S193>' : 'foc/FOC_control/speed_pid/Speed_pid/N Gain'\r\n * '<S194>' : 'foc/FOC_control/speed_pid/Speed_pid/P Copy'\r\n * '<S195>' : 'foc/FOC_control/speed_pid/Speed_pid/Parallel P Gain'\r\n * '<S196>' : 'foc/FOC_control/speed_pid/Speed_pid/Reset Signal'\r\n * '<S197>' : 'foc/FOC_control/speed_pid/Speed_pid/Saturation'\r\n * '<S198>' : 'foc/FOC_control/speed_pid/Speed_pid/Saturation Fdbk'\r\n * '<S199>' : 'foc/FOC_control/speed_pid/Speed_pid/Sum'\r\n * '<S200>' : 'foc/FOC_control/speed_pid/Speed_pid/Sum Fdbk'\r\n * '<S201>' : 'foc/FOC_control/speed_pid/Speed_pid/Tracking Mode'\r\n * '<S202>' : 'foc/FOC_control/speed_pid/Speed_pid/Tracking Mode Sum'\r\n * '<S203>' : 'foc/FOC_control/speed_pid/Speed_pid/Tsamp - Integral'\r\n * '<S204>' : 'foc/FOC_control/speed_pid/Speed_pid/Tsamp - Ngain'\r\n * '<S205>' : 'foc/FOC_control/speed_pid/Speed_pid/postSat Signal'\r\n * '<S206>' : 'foc/FOC_control/speed_pid/Speed_pid/preSat Signal'\r\n * '<S207>' : 'foc/FOC_control/speed_pid/Speed_pid/Anti-windup/Passthrough'\r\n * '<S208>' : 'foc/FOC_control/speed_pid/Speed_pid/D Gain/Disabled'\r\n * '<S209>' : 'foc/FOC_control/speed_pid/Speed_pid/Filter/Disabled'\r\n * '<S210>' : 'foc/FOC_control/speed_pid/Speed_pid/Filter ICs/Disabled'\r\n * '<S211>' : 'foc/FOC_control/speed_pid/Speed_pid/I Gain/Internal Parameters'\r\n * '<S212>' : 'foc/FOC_control/speed_pid/Speed_pid/Ideal P Gain/Passthrough'\r\n * '<S213>' : 'foc/FOC_control/speed_pid/Speed_pid/Ideal P Gain Fdbk/Disabled'\r\n * '<S214>' : 'foc/FOC_control/speed_pid/Speed_pid/Integrator/Discrete'\r\n * '<S215>' : 'foc/FOC_control/speed_pid/Speed_pid/Integrator ICs/Internal IC'\r\n * '<S216>' : 'foc/FOC_control/speed_pid/Speed_pid/N Copy/Disabled wSignal Specification'\r\n * '<S217>' : 'foc/FOC_control/speed_pid/Speed_pid/N Gain/Disabled'\r\n * '<S218>' : 'foc/FOC_control/speed_pid/Speed_pid/P Copy/Disabled'\r\n * '<S219>' : 'foc/FOC_control/speed_pid/Speed_pid/Parallel P Gain/Internal Parameters'\r\n * '<S220>' : 'foc/FOC_control/speed_pid/Speed_pid/Reset Signal/Disabled'\r\n * '<S221>' : 'foc/FOC_control/speed_pid/Speed_pid/Saturation/Enabled'\r\n * '<S222>' : 'foc/FOC_control/speed_pid/Speed_pid/Saturation Fdbk/Disabled'\r\n * '<S223>' : 'foc/FOC_control/speed_pid/Speed_pid/Sum/Sum_PI'\r\n * '<S224>' : 'foc/FOC_control/speed_pid/Speed_pid/Sum Fdbk/Disabled'\r\n * '<S225>' : 'foc/FOC_control/speed_pid/Speed_pid/Tracking Mode/Disabled'\r\n * '<S226>' : 'foc/FOC_control/speed_pid/Speed_pid/Tracking Mode Sum/Passthrough'\r\n * '<S227>' : 'foc/FOC_control/speed_pid/Speed_pid/Tsamp - Integral/Passthrough'\r\n * '<S228>' : 'foc/FOC_control/speed_pid/Speed_pid/Tsamp - Ngain/Passthrough'\r\n * '<S229>' : 'foc/FOC_control/speed_pid/Speed_pid/postSat Signal/Forward_Path'\r\n * '<S230>' : 'foc/FOC_control/speed_pid/Speed_pid/preSat Signal/Forward_Path'\r\n */\r\n#endif                                 /* RTW_HEADER_FOC_control_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"FOC_control_private.h","type":"header","group":"model","path":"D:\\DATA\\simulink\\data\\FOC_control_ert_rtw","tag":"","groupDisplay":"模型文件","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: FOC_control_private.h\r\n *\r\n * Code generated for Simulink model 'FOC_control'.\r\n *\r\n * Model version                  : 5.63\r\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\r\n * C/C++ source code generated on : Sat Feb  8 23:02:14 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: STMicroelectronics->ST10/Super10\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_FOC_control_private_h_\r\n#define RTW_HEADER_FOC_control_private_h_\r\n#include \"rtwtypes.h\"\r\n#include \"FOC_control_types.h\"\r\n#include \"FOC_control.h\"\r\n\r\nextern real_T rt_remd_snf(real_T u0, real_T u1);\r\nextern real_T rt_hypotd_snf(real_T u0, real_T u1);\r\nextern real_T rt_atan2d_snf(real_T u0, real_T u1);\r\nextern real_T rt_modd_snf(real_T u0, real_T u1);\r\nextern real_T look1_pbinlxpw(real_T u0, const real_T bp0[], const real_T table[],\r\n  uint32_T prevIndex[], uint32_T maxIndex);\r\n\r\n#endif                                 /* RTW_HEADER_FOC_control_private_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"FOC_control_types.h","type":"header","group":"model","path":"D:\\DATA\\simulink\\data\\FOC_control_ert_rtw","tag":"","groupDisplay":"模型文件","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: FOC_control_types.h\r\n *\r\n * Code generated for Simulink model 'FOC_control'.\r\n *\r\n * Model version                  : 5.63\r\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\r\n * C/C++ source code generated on : Sat Feb  8 23:02:14 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: STMicroelectronics->ST10/Super10\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_FOC_control_types_h_\r\n#define RTW_HEADER_FOC_control_types_h_\r\n\r\n/* Forward declaration for rtModel */\r\ntypedef struct tag_RTM_FOC_control_T RT_MODEL_FOC_control_T;\r\n\r\n#endif                                 /* RTW_HEADER_FOC_control_types_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"FOC_control_data.c","type":"source","group":"data","path":"D:\\DATA\\simulink\\data\\FOC_control_ert_rtw","tag":"","groupDisplay":"数据文件","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: FOC_control_data.c\r\n *\r\n * Code generated for Simulink model 'FOC_control'.\r\n *\r\n * Model version                  : 5.63\r\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\r\n * C/C++ source code generated on : Sat Feb  8 23:02:14 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: STMicroelectronics->ST10/Super10\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"FOC_control.h\"\r\n\r\n/* Invariant block signals (default storage) */\r\nconst ConstB_FOC_control_T FOC_control_ConstB = {\r\n  1.25                                 /* '<S10>/Gain' */\r\n};\r\n\r\n/* Constant parameters (default storage) */\r\nconst ConstP_FOC_control_T FOC_control_ConstP = {\r\n  /* Pooled Parameter (Mixed Expressions)\r\n   * Referenced by:\r\n   *   '<S121>/Look-Up Table  Determine the sector of U* based on alpha (rad). '\r\n   *   '<S124>/1-D Lookup Table'\r\n   *   '<S130>/1-D Lookup Table'\r\n   *   '<S130>/1-D Lookup Table1'\r\n   *   '<S130>/1-D Lookup Table2'\r\n   *   '<S130>/1-D Lookup Table3'\r\n   */\r\n  { 1.0, 2.0, 3.0, 4.0, 5.0, 6.0 },\r\n\r\n  /* Pooled Parameter (Expression: [0:pi/3:5*pi/3])\r\n   * Referenced by:\r\n   *   '<S121>/Look-Up Table  Determine the sector of U* based on alpha (rad). '\r\n   *   '<S124>/1-D Lookup Table'\r\n   */\r\n  { 0.0, 1.0471975511965976, 2.0943951023931953, 3.1415926535897936,\r\n    4.1887902047863914, 5.2359877559829888 },\r\n\r\n  /* Expression: pat1\r\n   * Referenced by: '<S125>/Direct Look-Up Table (n-D)'\r\n   */\r\n  { 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0,\r\n    1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0,\r\n    1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,\r\n    0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0,\r\n    0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0,\r\n    0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0,\r\n    1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0,\r\n    0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.0, 1.0,\r\n    1.0, 0.0, 0.0, 0.0, 0.0, 0.0 }\r\n};\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetInf.c","type":"source","group":"utility","path":"D:\\DATA\\simulink\\data\\FOC_control_ert_rtw","tag":"","groupDisplay":"实用工具文件","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtGetInf.c\r\n *\r\n * Code generated for Simulink model 'FOC_control'.\r\n *\r\n * Model version                  : 5.63\r\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\r\n * C/C++ source code generated on : Sat Feb  8 23:02:14 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: STMicroelectronics->ST10/Super10\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rtGetInf.h\"\r\n#include <stddef.h>\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T inf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    inf = rtGetInfF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0x7FF00000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    inf = tmpVal.fltVal;\r\n  }\r\n\r\n  return inf;\r\n}\r\n\r\n/*\r\n * Initialize rtInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetInfF(void)\r\n{\r\n  IEEESingle infF;\r\n  infF.wordL.wordLuint = 0x7F800000U;\r\n  return infF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInf needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetMinusInf(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T minf = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    minf = rtGetMinusInfF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0xFFF00000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    minf = tmpVal.fltVal;\r\n  }\r\n\r\n  return minf;\r\n}\r\n\r\n/*\r\n * Initialize rtMinusInfF needed by the generated code.\r\n * Inf is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetMinusInfF(void)\r\n{\r\n  IEEESingle minfF;\r\n  minfF.wordL.wordLuint = 0xFF800000U;\r\n  return minfF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetInf.h","type":"header","group":"utility","path":"D:\\DATA\\simulink\\data\\FOC_control_ert_rtw","tag":"","groupDisplay":"实用工具文件","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtGetInf.h\r\n *\r\n * Code generated for Simulink model 'FOC_control'.\r\n *\r\n * Model version                  : 5.63\r\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\r\n * C/C++ source code generated on : Sat Feb  8 23:02:14 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: STMicroelectronics->ST10/Super10\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtGetInf_h_\r\n#define RTW_HEADER_rtGetInf_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtGetInf(void);\r\nextern real32_T rtGetInfF(void);\r\nextern real_T rtGetMinusInf(void);\r\nextern real32_T rtGetMinusInfF(void);\r\n\r\n#endif                                 /* RTW_HEADER_rtGetInf_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetNaN.c","type":"source","group":"utility","path":"D:\\DATA\\simulink\\data\\FOC_control_ert_rtw","tag":"","groupDisplay":"实用工具文件","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtGetNaN.c\r\n *\r\n * Code generated for Simulink model 'FOC_control'.\r\n *\r\n * Model version                  : 5.63\r\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\r\n * C/C++ source code generated on : Sat Feb  8 23:02:14 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: STMicroelectronics->ST10/Super10\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtwtypes.h\"\r\n#include \"rtGetNaN.h\"\r\n#include <stddef.h>\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\n/*\r\n * Initialize rtNaN needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal_T rtGetNaN(void)\r\n{\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  real_T nan = 0.0;\r\n  if (bitsPerReal == 32U) {\r\n    nan = rtGetNaNF();\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.bitVal.words.wordH = 0xFFF80000U;\r\n    tmpVal.bitVal.words.wordL = 0x00000000U;\r\n    nan = tmpVal.fltVal;\r\n  }\r\n\r\n  return nan;\r\n}\r\n\r\n/*\r\n * Initialize rtNaNF needed by the generated code.\r\n * NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nreal32_T rtGetNaNF(void)\r\n{\r\n  IEEESingle nanF = { { 0.0F } };\r\n\r\n  nanF.wordL.wordLuint = 0xFFC00000U;\r\n  return nanF.wordL.wordLreal;\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtGetNaN.h","type":"header","group":"utility","path":"D:\\DATA\\simulink\\data\\FOC_control_ert_rtw","tag":"","groupDisplay":"实用工具文件","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtGetNaN.h\r\n *\r\n * Code generated for Simulink model 'FOC_control'.\r\n *\r\n * Model version                  : 5.63\r\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\r\n * C/C++ source code generated on : Sat Feb  8 23:02:14 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: STMicroelectronics->ST10/Super10\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rtGetNaN_h_\r\n#define RTW_HEADER_rtGetNaN_h_\r\n#include \"rtwtypes.h\"\r\n\r\nextern real_T rtGetNaN(void);\r\nextern real32_T rtGetNaNF(void);\r\n\r\n#endif                                 /* RTW_HEADER_rtGetNaN_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rt_defines.h","type":"header","group":"utility","path":"D:\\DATA\\simulink\\data\\FOC_control_ert_rtw","tag":"","groupDisplay":"实用工具文件","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rt_defines.h\r\n *\r\n * Code generated for Simulink model 'FOC_control'.\r\n *\r\n * Model version                  : 5.63\r\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\r\n * C/C++ source code generated on : Sat Feb  8 23:02:14 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: STMicroelectronics->ST10/Super10\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rt_defines_h_\r\n#define RTW_HEADER_rt_defines_h_\r\n\r\n/*===========*\r\n * Constants *\r\n *===========*/\r\n#define RT_PI                          3.14159265358979323846\r\n#define RT_PIF                         3.1415927F\r\n#define RT_LN_10                       2.30258509299404568402\r\n#define RT_LN_10F                      2.3025851F\r\n#define RT_LOG10E                      0.43429448190325182765\r\n#define RT_LOG10EF                     0.43429449F\r\n#define RT_E                           2.7182818284590452354\r\n#define RT_EF                          2.7182817F\r\n\r\n/*\r\n * UNUSED_PARAMETER(x)\r\n *   Used to specify that a function parameter (argument) is required but not\r\n *   accessed by the function body.\r\n */\r\n#ifndef UNUSED_PARAMETER\r\n#if defined(__LCC__)\r\n#define UNUSED_PARAMETER(x)                                      /* do nothing */\r\n#else\r\n\r\n/*\r\n * This is the semi-ANSI standard way of indicating that an\r\n * unused function parameter is required.\r\n */\r\n#define UNUSED_PARAMETER(x)            (void) (x)\r\n#endif\r\n#endif\r\n#endif                                 /* RTW_HEADER_rt_defines_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rt_nonfinite.c","type":"source","group":"utility","path":"D:\\DATA\\simulink\\data\\FOC_control_ert_rtw","tag":"","groupDisplay":"实用工具文件","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rt_nonfinite.c\r\n *\r\n * Code generated for Simulink model 'FOC_control'.\r\n *\r\n * Model version                  : 5.63\r\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\r\n * C/C++ source code generated on : Sat Feb  8 23:02:14 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: STMicroelectronics->ST10/Super10\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#include \"rtGetNaN.h\"\r\n#include \"rtGetInf.h\"\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#include \"rt_nonfinite.h\"\r\n#define NumBitsPerChar                 8U\r\n\r\nreal_T rtInf;\r\nreal_T rtMinusInf;\r\nreal_T rtNaN;\r\nreal32_T rtInfF;\r\nreal32_T rtMinusInfF;\r\nreal32_T rtNaNF;\r\n\r\n/*\r\n * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\r\n * generated code. NaN is initialized as non-signaling. Assumes IEEE.\r\n */\r\nvoid rt_InitInfAndNaN(size_t realSize)\r\n{\r\n  (void) (realSize);\r\n  rtNaN = rtGetNaN();\r\n  rtNaNF = rtGetNaNF();\r\n  rtInf = rtGetInf();\r\n  rtInfF = rtGetInfF();\r\n  rtMinusInf = rtGetMinusInf();\r\n  rtMinusInfF = rtGetMinusInfF();\r\n}\r\n\r\n/* Test if value is infinite */\r\nboolean_T rtIsInf(real_T value)\r\n{\r\n  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\r\n}\r\n\r\n/* Test if single-precision value is infinite */\r\nboolean_T rtIsInfF(real32_T value)\r\n{\r\n  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\r\n}\r\n\r\n/* Test if value is not a number */\r\nboolean_T rtIsNaN(real_T value)\r\n{\r\n  boolean_T result = (boolean_T) 0;\r\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\r\n  if (bitsPerReal == 32U) {\r\n    result = rtIsNaNF((real32_T)value);\r\n  } else {\r\n    union {\r\n      LittleEndianIEEEDouble bitVal;\r\n      real_T fltVal;\r\n    } tmpVal;\r\n\r\n    tmpVal.fltVal = value;\r\n    result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) == 0x7FF00000 &&\r\n                         ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\r\n                          (tmpVal.bitVal.words.wordL != 0) ));\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/* Test if single-precision value is not a number */\r\nboolean_T rtIsNaNF(real32_T value)\r\n{\r\n  IEEESingle tmp;\r\n  tmp.wordL.wordLreal = value;\r\n  return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\r\n                     (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\r\n}\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rt_nonfinite.h","type":"header","group":"utility","path":"D:\\DATA\\simulink\\data\\FOC_control_ert_rtw","tag":"","groupDisplay":"实用工具文件","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rt_nonfinite.h\r\n *\r\n * Code generated for Simulink model 'FOC_control'.\r\n *\r\n * Model version                  : 5.63\r\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\r\n * C/C++ source code generated on : Sat Feb  8 23:02:14 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: STMicroelectronics->ST10/Super10\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTW_HEADER_rt_nonfinite_h_\r\n#define RTW_HEADER_rt_nonfinite_h_\r\n#include <stddef.h>\r\n#include \"rtwtypes.h\"\r\n#define NOT_USING_NONFINITE_LITERALS   1\r\n\r\nextern real_T rtInf;\r\nextern real_T rtMinusInf;\r\nextern real_T rtNaN;\r\nextern real32_T rtInfF;\r\nextern real32_T rtMinusInfF;\r\nextern real32_T rtNaNF;\r\nextern void rt_InitInfAndNaN(size_t realSize);\r\nextern boolean_T rtIsInf(real_T value);\r\nextern boolean_T rtIsInfF(real32_T value);\r\nextern boolean_T rtIsNaN(real_T value);\r\nextern boolean_T rtIsNaNF(real32_T value);\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordH;\r\n    uint32_T wordL;\r\n  } words;\r\n} BigEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  struct {\r\n    uint32_T wordL;\r\n    uint32_T wordH;\r\n  } words;\r\n} LittleEndianIEEEDouble;\r\n\r\ntypedef struct {\r\n  union {\r\n    real32_T wordLreal;\r\n    uint32_T wordLuint;\r\n  } wordL;\r\n} IEEESingle;\r\n\r\n#endif                                 /* RTW_HEADER_rt_nonfinite_h_ */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"D:\\DATA\\simulink\\data\\FOC_control_ert_rtw","tag":"","groupDisplay":"实用工具文件","code":"/*\r\n * Academic License - for use in teaching, academic research, and meeting\r\n * course requirements at degree granting institutions only.  Not for\r\n * government, commercial, or other organizational use.\r\n *\r\n * File: rtwtypes.h\r\n *\r\n * Code generated for Simulink model 'FOC_control'.\r\n *\r\n * Model version                  : 5.63\r\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\r\n * C/C++ source code generated on : Sat Feb  8 23:02:14 2025\r\n *\r\n * Target selection: ert.tlc\r\n * Embedded hardware selection: STMicroelectronics->ST10/Super10\r\n * Code generation objectives: Unspecified\r\n * Validation result: Not run\r\n */\r\n\r\n#ifndef RTWTYPES_H\r\n#define RTWTYPES_H\r\n\r\n/* Logical type definitions */\r\n#if (!defined(__cplusplus))\r\n#ifndef false\r\n#define false                          (0U)\r\n#endif\r\n\r\n#ifndef true\r\n#define true                           (1U)\r\n#endif\r\n#endif\r\n\r\n/*=======================================================================*\r\n * Target hardware information\r\n *   Device type: STMicroelectronics->ST10/Super10\r\n *   Number of bits:     char:   8    short:   16    int:  16\r\n *                       long:  32\r\n *                       native word size:  16\r\n *   Byte ordering: LittleEndian\r\n *   Signed integer division rounds to: Zero\r\n *   Shift right on a signed integer as arithmetic shift: on\r\n *=======================================================================*/\r\n\r\n/*=======================================================================*\r\n * Fixed width word size data types:                                     *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\r\n *=======================================================================*/\r\ntypedef signed char int8_T;\r\ntypedef unsigned char uint8_T;\r\ntypedef int int16_T;\r\ntypedef unsigned int uint16_T;\r\ntypedef long int32_T;\r\ntypedef unsigned long uint32_T;\r\ntypedef float real32_T;\r\ntypedef double real64_T;\r\n\r\n/*===========================================================================*\r\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\r\n *                           real_T, time_T, ulong_T.                        *\r\n *===========================================================================*/\r\ntypedef double real_T;\r\ntypedef double time_T;\r\ntypedef unsigned char boolean_T;\r\ntypedef int int_T;\r\ntypedef unsigned int uint_T;\r\ntypedef unsigned long ulong_T;\r\ntypedef char char_T;\r\ntypedef unsigned char uchar_T;\r\ntypedef char_T byte_T;\r\n\r\n/*===========================================================================*\r\n * Complex number type definitions                                           *\r\n *===========================================================================*/\r\n#define CREAL_T\r\n\r\ntypedef struct {\r\n  real32_T re;\r\n  real32_T im;\r\n} creal32_T;\r\n\r\ntypedef struct {\r\n  real64_T re;\r\n  real64_T im;\r\n} creal64_T;\r\n\r\ntypedef struct {\r\n  real_T re;\r\n  real_T im;\r\n} creal_T;\r\n\r\n#define CINT8_T\r\n\r\ntypedef struct {\r\n  int8_T re;\r\n  int8_T im;\r\n} cint8_T;\r\n\r\n#define CUINT8_T\r\n\r\ntypedef struct {\r\n  uint8_T re;\r\n  uint8_T im;\r\n} cuint8_T;\r\n\r\n#define CINT16_T\r\n\r\ntypedef struct {\r\n  int16_T re;\r\n  int16_T im;\r\n} cint16_T;\r\n\r\n#define CUINT16_T\r\n\r\ntypedef struct {\r\n  uint16_T re;\r\n  uint16_T im;\r\n} cuint16_T;\r\n\r\n#define CINT32_T\r\n\r\ntypedef struct {\r\n  int32_T re;\r\n  int32_T im;\r\n} cint32_T;\r\n\r\n#define CUINT32_T\r\n\r\ntypedef struct {\r\n  uint32_T re;\r\n  uint32_T im;\r\n} cuint32_T;\r\n\r\n/*=======================================================================*\r\n * Min and Max:                                                          *\r\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\r\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\r\n *=======================================================================*/\r\n#define MAX_int8_T                     ((int8_T)(127))\r\n#define MIN_int8_T                     ((int8_T)(-128))\r\n#define MAX_uint8_T                    ((uint8_T)(255U))\r\n#define MAX_int16_T                    ((int16_T)(32767))\r\n#define MIN_int16_T                    ((int16_T)(-32768))\r\n#define MAX_uint16_T                   ((uint16_T)(65535U))\r\n#define MAX_int32_T                    ((int32_T)(2147483647L))\r\n#define MIN_int32_T                    ((int32_T)(-2147483647L-1L))\r\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFUL))\r\n\r\n/* Block D-Work pointer type */\r\ntypedef void * pointer_T;\r\n\r\n#endif                                 /* RTWTYPES_H */\r\n\r\n/*\r\n * File trailer for generated code.\r\n *\r\n * [EOF]\r\n */\r\n"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":false,"showJustificationLinks":false,"showProfilingInfo":false,"showTaskSummary":false}};